\documentclass[a4paper, 10pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{ucs}
\usepackage[danish]{babel}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage[parfill]{parskip}
\usepackage{listings}
\usepackage{upgreek}
\usepackage{amsthm}

\usepackage{mathtools}

\begin{document}

%Object:
% This project targets first-and-foremost efficient parallelization of the small dataset. This dataset corresponds to values OUTER=16, NUM_X = 32, NUM_Y = 256, and requires that all parallelism is exploited in order to efficiently utilize the GPGPU, i.e., the loops in the tridag function must also be parallelized. The latter requires the computation of several segmented scans (interleaved with maps) in the innermost dimension. However the segment size is either 32 or 256, which means that they can be performed at CUDA-block level, hence efficient. (Meaning, if the block size is chosen 256 then the elements of a segment will never cross two blocks, and in particular there is a multiple of segments that would fit exactly the size of the block.) You will receive ample help on how to reqrite tridag into segmented scans and how to parallelize the scans.



%Notes
% vi skal i rapporten argumentere for hvad vi kan og ikke kan parallelisere
% og så kommer det til at være meget privatization og loop expansion
% og så interchange det yderste, som ma ruler dem ud (som jeg lige forstod det)
% og så er der self noget loop distribution

% og han råder os til at lave CUDA som det sidste, efter alle loop-fixes
% vi starter i noget C++ kode, med vectors, fordi de simplificere koden - men skal ende i ren C fordi vi bruger CUDA
% så vi bør vente med CUDA-transformation til aller sidst.





\section{Benchmarks}

\subsection{CPU benchmark}
Benchmark on non-optimized code, CPU test:
With CPU argument and privatization of strike and PrivGlobs.
2291156 single cpu kernel local machine
907715 parallel 4 cpu kernels local machine
factor 20 improvement.






\end{document}